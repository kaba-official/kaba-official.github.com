
<!DOCTYPE html>
<html>
<head><meta name="generator" content="Hexo 3.9.0">
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-115014323-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-115014323-1');
  </script>
  <meta charset="utf-8">
  <title>The Linux COW | East River Village</title>
  <meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1,minimum-scale=1">
  <meta name="description" content="In our last post we have seen how to get the physical memory address using a virtual memory address. In this post lets try to check Copy on Write(COW from here) implemented by Linux. For those who try">
<meta name="keywords" content="memory_management,fork,clone,getpid,cow,stack,virtual_memory">
<meta property="og:type" content="article">
<meta property="og:title" content="The Linux COW">
<meta property="og:url" content="https://eastrivervillage.com/The-Linux-COW/index.html">
<meta property="og:site_name" content="East River Village">
<meta property="og:description" content="In our last post we have seen how to get the physical memory address using a virtual memory address. In this post lets try to check Copy on Write(COW from here) implemented by Linux. For those who try">
<meta property="og:locale" content="en">
<meta property="og:image" content="https://eastrivervillage.com/images/linux_cow.jpeg">
<meta property="og:updated_time" content="2020-08-09T06:51:47.867Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="The Linux COW">
<meta name="twitter:description" content="In our last post we have seen how to get the physical memory address using a virtual memory address. In this post lets try to check Copy on Write(COW from here) implemented by Linux. For those who try">
<meta name="twitter:image" content="https://eastrivervillage.com/images/linux_cow.jpeg">
  <link rel="icon" href="/favicon.ico">
  
  
    <!-- Google Tag Manager -->
    <script>(function(w,d,s,l,i){w[l]=w[l]||[];w[l].push({'gtm.start':
    new Date().getTime(),event:'gtm.js'});var f=d.getElementsByTagName(s)[0],
    j=d.createElement(s),dl=l!='dataLayer'?'&l='+l:'';j.async=true;j.src=
    '//www.googletagmanager.com/gtm.js?id='+i+dl;f.parentNode.insertBefore(j,f);
    })(window,document,'script','dataLayer','GTM-5LB7LCD');</script>
    <!-- End Google Tag Manager -->
  


  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/bulma/0.6.1/css/bulma.min.css">
  <link rel="stylesheet" href="https://maxcdn.bootstrapcdn.com/font-awesome/4.7.0/css/font-awesome.min.css">
  <link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Roboto|Merriweather|Lobster|Lora|Roboto Mono">
  <link rel="stylesheet" href="/css/style.css">
  
<script type="application/ld+json">
  {
  "@context": "http://schema.org",
  "@type": "BlogPosting",
  "headline": "The Linux COW",
  "name": "The Linux COW",
  "image": "/images/linux_cow.jpeg",
  "datePublished": "2018-03-05T16:29:30.000Z",
  "dateModified": "2020-08-09T06:51:47.867Z",
  "mainEntityOfPage": {
    "@type": "WebPage",
    "@id": "https://eastrivervillage.com/The-Linux-COW/index.html"
  },
  "author": {
    "@type": "Person",
    "name": "Balakumaran Kannan",
    "image": "/images/profile_author.jpg",
    "description": "System software engineer specilied in Linux. Experience spans from ARM32 board bring-up to multi datacenter cloud management. Open source contributer. From Bangalore, India."
  },
  "publisher": {
    "@type": "Organization",
    "name": "Balakumaran Kannan",
    "logo": {
      "@type": "ImageObject",
      "url": "/images/profile_author.jpg"
    }
  }
}
</script>

  
</head>
</html>
<body>
  
  
    <!-- Google Tag Manager -->
    <script>(function(w,d,s,l,i){w[l]=w[l]||[];w[l].push({'gtm.start':
    new Date().getTime(),event:'gtm.js'});var f=d.getElementsByTagName(s)[0],
    j=d.createElement(s),dl=l!='dataLayer'?'&l='+l:'';j.async=true;j.src=
    '//www.googletagmanager.com/gtm.js?id='+i+dl;f.parentNode.insertBefore(j,f);
    })(window,document,'script','dataLayer','GTM-5LB7LCD');</script>
    <!-- End Google Tag Manager -->
  


  <header class="navbar" role="navigation" aria-label="main navigation">
  <div class="navbar-brand">
    <a href="/" class="navbar-item">
      East River Village
    </a>
  </div>
</header>

  <div class="container">
    <div class="columns">
      <div style="overflow:hidden;" class="main column">
        <article class="post">
  <figure class="post-thumbnail">
    
  <img src="/images/linux_cow.jpeg" class="thumbnail " alt="The Linux COW">


  </figure>
  <span>2018-03-05
</span>
  <h1 class="title">The Linux COW</h1>
  
  <div class="tags">
    
      <a class="tag is-white" style="color: darkmagenta; padding-left:0;" href="/tags/memory-management/">memory_management</a>
    
      <a class="tag is-white" style="color: darkmagenta; padding-left:0;" href="/tags/fork/">fork</a>
    
      <a class="tag is-white" style="color: darkmagenta; padding-left:0;" href="/tags/clone/">clone</a>
    
      <a class="tag is-white" style="color: darkmagenta; padding-left:0;" href="/tags/getpid/">getpid</a>
    
      <a class="tag is-white" style="color: darkmagenta; padding-left:0;" href="/tags/cow/">cow</a>
    
      <a class="tag is-white" style="color: darkmagenta; padding-left:0;" href="/tags/stack/">stack</a>
    
      <a class="tag is-white" style="color: darkmagenta; padding-left:0;" href="/tags/virtual-memory/">virtual_memory</a>
    
  </div>


  <div class="content">
    <p>In our <a href="/Virtual-memory-to-Physical-memory/">last post</a> we have seen how to get the physical memory address using a virtual memory address. In this post lets try to check Copy on Write(<em>COW</em> from here) implemented by Linux. For those who try to recollect what is COW, on <code>fork()</code>, Linux will not immediately replicate the address space of parent process. As the child process is most-likely to load a new binary, copying the current process’s address space will be of no use in many cases. So unless a write occurs (either by the parent process or by the child process), the physical address space mapped to both processes’ virtual address space will be same. Please go through <a href="https://en.wikipedia.org/wiki/Copy-on-write" target="_blank" rel="noopener">Wikipedia</a> if you still have no clue.</p>
<p>So lets write a C program that forks itself and check whether both are sharing the physical address space. We are going to reuse the <code>get_paddr.c</code> function we wrote in our <a href="/Virtual-memory-to-Physical-memory/">previous post</a> to get the physical memory address.<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt; /* fork() */</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> a;</span><br><span class="line"></span><br><span class="line">	fork();</span><br><span class="line"></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"my pid is %d, and the address to work is 0x%lx\n"</span>, getpid(), (<span class="keyword">unsigned</span> <span class="keyword">long</span>)&amp;a);</span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">"%d\n"</span>, &amp;a);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>Execute this program in one console and while it is waiting for the user input, go to the next console and get the physical address of variable <code>a</code> using our <code>get_paddr</code> binary.<br><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ gcc specimen.c -o specimen</span><br><span class="line">$ ./specimen</span><br><span class="line">my pid is 5912, and the address to work is 0x7ffd055923e4</span><br><span class="line">my pid is 5913, and the address to work is 0x7ffd055923e4</span><br></pre></td></tr></table></figure></p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">$ sudo ./get_paddr 5912 0x7ffd055923e4</span><br><span class="line">getting page number of virtual address 140724693181412 of process 5912</span><br><span class="line">opening pagemap /proc/5912/pagemap</span><br><span class="line">moving to 274852916368</span><br><span class="line">physical frame address is 0x509c9</span><br><span class="line">physical address is 0x509c93e4</span><br><span class="line">$</span><br><span class="line">$ sudo ./get_paddr 5913 0x7ffd055923e4</span><br><span class="line">getting page number of virtual address 140724693181412 of process 5913</span><br><span class="line">opening pagemap /proc/5913/pagemap</span><br><span class="line">moving to 274852916368</span><br><span class="line">physical frame address is 0x64d2a</span><br><span class="line">physical address is 0x64d2a3e4</span><br><span class="line">$</span><br></pre></td></tr></table></figure>
<p><strong>OOPS!</strong> The physical address is not same! How? Why? What’s wrong? As per my beloved <em>Robert Love’s Linux System Programming</em> book, the physical memory copy will occur only when a write occurs.</p>
<blockquote><p>The MMU can intercept the write operation and raise an exception; the kernel, in response, will transparently create a new copy of the page for the writing process, and allow the write to continue against the new page. We call this approach *copy-on-write(COW). Effectively, processes are allowed read access to shared data, which saves space. But when a process wants to write to a shared page, it receives a unique copy of that page on fly, thereby allowing the kernel to act as if the process always had its own private copy. As copy-on write occurs on a page-by-page basis, with the technique a huge file may be efficiently shared among many processes, and the individual processes will receive unique physical pages only for those pages to which thy themselves write.</p>
<footer><strong>Robert Love </strong><cite>Linux System Programming</cite></footer></blockquote>
<p>It is so clear that in our program <code>specimen.c</code> we never write to the only variable <code>a</code> unless the <code>scanf</code> completes. But we tested the <em>COW</em> before input-ing to the <code>scanf</code>. So by the time there would be no write and as per the design of <em>COW</em> physical memory space should be shared across both parent and child. Even though we have written the program carefully, sometimes the libraries, compiler and even the OS will act intelligently (stupid! They themselves says it) and fills us with surprise. So lets run the handy <code>strace</code> on our <code>specimen</code> binary to see what it actually does.<br><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">$ strace ./specimen </span><br><span class="line">execve(<span class="string">"./specimen"</span>, [<span class="string">"./specimen"</span>], [/* 47 vars */]) = 0</span><br><span class="line">brk(NULL)                               = 0x55de17b57000</span><br><span class="line">access(<span class="string">"/etc/ld.so.nohwcap"</span>, F_OK)      = -1 ENOENT (No such file or directory)</span><br><span class="line">access(<span class="string">"/etc/ld.so.preload"</span>, R_OK)      = -1 ENOENT (No such file or directory)</span><br><span class="line">openat(AT_FDCWD, <span class="string">"/etc/ld.so.cache"</span>, O_RDONLY|O_CLOEXEC) = 3</span><br><span class="line">fstat(3, &#123;st_mode=S_IFREG|0644, st_size=94696, ...&#125;) = 0</span><br><span class="line">mmap(NULL, 94696, PROT_READ, MAP_PRIVATE, 3, 0) = 0x7fdbad5b8000</span><br><span class="line">close(3)                                = 0</span><br><span class="line">access(<span class="string">"/etc/ld.so.nohwcap"</span>, F_OK)      = -1 ENOENT (No such file or directory)</span><br><span class="line">openat(AT_FDCWD, <span class="string">"/lib/x86_64-linux-gnu/libc.so.6"</span>, O_RDONLY|O_CLOEXEC) = 3</span><br><span class="line"><span class="built_in">read</span>(3, <span class="string">"\177ELF\2\1\1\3\0\0\0\0\0\0\0\0\3\0&gt;\0\1\0\0\0\340\22\2\0\0\0\0\0"</span>..., 832) = 832</span><br><span class="line">fstat(3, &#123;st_mode=S_IFREG|0755, st_size=1960656, ...&#125;) = 0</span><br><span class="line">mmap(NULL, 8192, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_ANONYMOUS, -1, 0) = 0x7fdbad5b6000</span><br><span class="line">mmap(NULL, 4061792, PROT_READ|PROT_EXEC, MAP_PRIVATE|MAP_DENYWRITE, 3, 0) = 0x7fdbacfc9000</span><br><span class="line">mprotect(0x7fdbad19f000, 2097152, PROT_NONE) = 0</span><br><span class="line">mmap(0x7fdbad39f000, 24576, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_FIXED|MAP_DENYWRITE, </span><br><span class="line">		3, 0x1d6000) = 0x7fdbad39f000</span><br><span class="line">mmap(0x7fdbad3a5000, 14944, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_FIXED|MAP_ANONYMOUS, </span><br><span class="line">		-1, 0) = 0x7fdbad3a5000</span><br><span class="line">close(3)                                = 0</span><br><span class="line">arch_prctl(ARCH_SET_FS, 0x7fdbad5b7500) = 0</span><br><span class="line">mprotect(0x7fdbad39f000, 16384, PROT_READ) = 0</span><br><span class="line">mprotect(0x55de15e94000, 4096, PROT_READ) = 0</span><br><span class="line">mprotect(0x7fdbad5d0000, 4096, PROT_READ) = 0</span><br><span class="line">munmap(0x7fdbad5b8000, 94696)           = 0</span><br><span class="line"><span class="built_in">clone</span>(child_stack=NULL, flags=CLONE_CHILD_CLEARTID|CLONE_CHILD_SETTID|SIGCHLD, </span><br><span class="line">		child_tidptr=0x7fdbad5b77d0) = 5932</span><br><span class="line">getpid()                                = 5931</span><br><span class="line">fstat(1, &#123;st_mode=S_IFCHR|0620, st_rdev=makedev(136, 2), ...&#125;) = 0</span><br><span class="line">my pid is 5932, and the address to work is 0x7fff9823b814</span><br><span class="line">brk(NULL)                               = 0x55de17b57000</span><br><span class="line">brk(0x55de17b78000)                     = 0x55de17b78000</span><br><span class="line">write(1, <span class="string">"my pid is 5931, and the address "</span>..., 58my pid is 5931, and the address </span><br><span class="line">		to work is 0x7fff9823b814</span><br><span class="line">) = 58</span><br><span class="line">fstat(0, &#123;st_mode=S_IFCHR|0620, st_rdev=makedev(136, 2), ...&#125;) = 0</span><br><span class="line"><span class="built_in">read</span>(0,</span><br></pre></td></tr></table></figure></p>
<p>As the program is waiting on <code>scanf</code>, it is waiting for user input in <code>read</code> system-call from <code>fd 0</code>, <code>stdin</code>. But the surprise part here is the <code>clone</code> system call. If you don’t remember, read the <code>specimen.c</code> program once again. We never used the <code>clone</code> system call. And where is the <code>fork</code>? It seems <code>glibc</code> does something in a so called <em>intelligent</em> way. Lets read the <code>man pages</code> once again for pointers.<br><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">C library/kernel differences</span><br><span class="line">       Since  version  2.3.3, rather than invoking the kernel<span class="string">'s fork() system call,</span></span><br><span class="line"><span class="string">	   the glibc fork() wrapper that is provided as part of the NPTL threading </span></span><br><span class="line"><span class="string">	   implementation invokes clone(2) with flags that provide the same effect as </span></span><br><span class="line"><span class="string">	   the traditional system call.  (A call to fork() is equivalent to a call to </span></span><br><span class="line"><span class="string">	   clone(2) specifying flags as just  SIGCHLD.) The glibc wrapper invokes any </span></span><br><span class="line"><span class="string">	   fork handlers that have been established using pthread_atfork(3).</span></span><br></pre></td></tr></table></figure></p>
<p>Doesn’t look completely true. Though the <code>man page</code> says it calls <code>clone()</code> with flags as just <code>SIGCHLD</code>, <code>strace</code> uncovers the dirty truth - <code>flags=CLONE_CHILD_CLEARTID|CLONE_CHILD_SETTID|SIGCHLD</code>. Nobody escapes from an armed system programmer.  Anyway this explains <code>clone</code> but no-<code>fork</code> surprise. But where comes the write that causes <code>COW</code>. See the last argument of <code>clone()</code> in <code>strace</code>, <code>child_tidptr=0x7fdbad5b77d0</code> some place holder stack variable passed to be filled. And what about the two flags other than <code>SIGCHLD</code>? Lets go to the <code>man pages</code> once again, but for <code>clone()</code> this time.<br><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">  CLONE_CHILD_CLEARTID (since Linux 2.5.49)</span><br><span class="line">      Clear (zero) the child thread ID at the location ctid <span class="keyword">in</span> child memory when </span><br><span class="line">the child exits, and <span class="keyword">do</span> a wakeup on the futex at that address.  The address </span><br><span class="line">involved  may be changed by the set_tid_address(2) system call.  This is </span><br><span class="line">used by threading libraries.</span><br><span class="line"></span><br><span class="line">  CLONE_CHILD_SETTID (since Linux 2.5.49)</span><br><span class="line">      Store the child thread ID at the location ctid <span class="keyword">in</span> the child<span class="string">'s memory. </span></span><br><span class="line"><span class="string">The store operation completes before clone() returns control to user space.</span></span><br></pre></td></tr></table></figure></p>
<p>Ahh! The culprit is <code>CLONE_CHILD_SETTID</code>. It makes the OS to write thread ID of the child into its memory region. This write triggers the <code>COW</code> and gets the child a fresh copy of physical memory. Sorry Linux, I doubted you.</p>
<p>Okay. Lets modify our <code>specimen</code> with <code>clone()</code> and no <code>CLONE_CHILD_SETTID</code> flag.<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* clone() */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> _GNU_SOURCE</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sched.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* getpid() */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;signal.h&gt; /* SIGCHLD */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt; /* malloc() */</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">run</span><span class="params">(<span class="keyword">void</span> *arg)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"my pid is %d and address to check is 0x%lx\n"</span>, getpid(), (<span class="keyword">unsigned</span> <span class="keyword">long</span>) arg);</span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">"%d\n"</span>, (<span class="keyword">int</span> *)arg);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> a;</span><br><span class="line">	<span class="keyword">void</span> *stack_ptr = <span class="built_in">malloc</span>(<span class="number">1024</span>*<span class="number">1024</span>);</span><br><span class="line">	<span class="keyword">if</span> (stack_ptr == <span class="literal">NULL</span>) &#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"No virtual memory available\n"</span>);</span><br><span class="line">		<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">/*fork();*/</span></span><br><span class="line"></span><br><span class="line">	clone(run, (stack_ptr + <span class="number">1024</span>*<span class="number">1024</span>), CLONE_CHILD_CLEARTID|SIGCHLD, &amp;a);</span><br><span class="line">	<span class="keyword">if</span> (a &lt; <span class="number">0</span>)</span><br><span class="line">		perror(<span class="string">"clone failed. "</span>);</span><br><span class="line"></span><br><span class="line">	run(&amp;a);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>Unlike <code>fork()</code>, <code>clone()</code> doesn’t start the execution of child from the point where it returns.Instead it takes a function as an argument and runs the function in child process. Here we are passing <code>run()</code> function which prints the <code>pid</code> and <code>virtual address</code> of the variable <code>a</code>. After <code>clone()</code> the parent also calls the function <code>run()</code> so that we’ll get the <code>pid</code> of parent process.</p>
<p>Have you noted the second argument of <code>clone()</code>? It is the <code>stack</code> where child is going to execute. Again unlike <code>fork()</code>, <code>clone()</code> allows parent and child to share their resources like memory, signal handlers, open file descriptors, etc. As both cannot run in same <code>stack</code>, the parent process must allocate some space and give it to the child to use it as stack. <code>stack</code> grows downwards on all processors that run Linux, so the child-stack should point out to the topmost address of the memory region. That’s why we are passing the end of <code>malloc</code>ed memory. Lets execute the program and see whether both process share the same physical memory space.<br><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ ./specimen</span><br><span class="line">my pid is 3129 and address to check is 0x7fff396fdd6c</span><br><span class="line">my pid is 3130 and address to check is 0x7fff396fdd6c</span><br></pre></td></tr></table></figure></p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">$ sudo ./get_paddr 3129 0x7fff396fdd6c</span><br><span class="line">getting page number of virtual address 140734157020524 of process 3129</span><br><span class="line">opening pagemap /proc/3129/pagemap</span><br><span class="line">moving to 274871400424</span><br><span class="line">physical frame address is 0x5e35a</span><br><span class="line">physical address is 0x5e35ad6c</span><br><span class="line">$</span><br><span class="line">$ sudo ./get_paddr 3130 0x7fff396fdd6c</span><br><span class="line">getting page number of virtual address 140734157020524 of process 3130</span><br><span class="line">opening pagemap /proc/3130/pagemap</span><br><span class="line">moving to 274871400424</span><br><span class="line">physical frame address is 0x6a7cd</span><br><span class="line">physical address is 0x6a7cdd6c</span><br><span class="line">$</span><br></pre></td></tr></table></figure>
<p>Different again! Linux can’t be wrong. We should make sure we didn’t mess-up anything. Are we sure there will be no write in stack after <code>clone()</code> call?</p>
<ul>
<li>The child’s execution starts at function <code>run()</code></li>
<li>No variables are written until <code>scanf()</code> returns. Okay we’ll complete our examination before providing any input.</li>
<li>But the functions? OOPS! After clone, parent calls <code>run()</code> and then <code>printf()</code> but child calls <code>printf()</code> directly. All these function calls will make write in stack which triggers <em>COW</em>.</li>
</ul>
<p>Lets come-up with a different C-program with no function calls after <code>clone()</code> in both parent and child.</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* clone() */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> _GNU_SOURCE</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sched.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* getpid() */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;signal.h&gt; /* SIGCHLD */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt; /* malloc() */</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> STACK_LENGTH (1024*1024)</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">run</span><span class="params">(<span class="keyword">void</span> *arg)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">while</span>(*(<span class="keyword">int</span>*)arg);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> a = <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">void</span> *stack_ptr = <span class="built_in">malloc</span>(STACK_LENGTH);</span><br><span class="line">	<span class="keyword">if</span> (stack_ptr == <span class="literal">NULL</span>) &#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"No virtual memory available\n"</span>);</span><br><span class="line">		<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">/*fork();*/</span></span><br><span class="line"></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"my pid is %d and address to check is 0x%lx\n"</span>, getpid(), (<span class="keyword">unsigned</span> <span class="keyword">long</span>) &amp;a);</span><br><span class="line">	clone(run, (stack_ptr + STACK_LENGTH), CLONE_CHILD_CLEARTID|SIGCHLD, &amp;a);</span><br><span class="line">	<span class="keyword">if</span> (a &lt; <span class="number">0</span>)</span><br><span class="line">		perror(<span class="string">"clone failed. "</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">while</span> (a);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>We are not printing anything after <code>clone()</code> to avoid stack overwrite. So we have to assume the child process’s <code>pid</code> is parent <code>pid</code> + 1. This assumption is true most of the times. And we use infinite <code>while</code> loop to pause both processes. Loops use <code>jump</code> statements. So they will not cause any stack write. So this time we should see same physical address has been used by both processes. Lets see.<br><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ ./specimen</span><br><span class="line">my pid is 3436 and address to check is 0x7fffa920c1ec</span><br></pre></td></tr></table></figure></p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">$ sudo ./get_paddr 3436 0x7fffa920c1ec</span><br><span class="line">getting page number of virtual address 140736030884332 of process 3436</span><br><span class="line">opening pagemap /proc/3436/pagemap</span><br><span class="line">moving to 274875060320</span><br><span class="line">physical frame address is 0x67337</span><br><span class="line">physical address is 0x673371ec</span><br><span class="line">$</span><br><span class="line">$ sudo ./get_paddr 3437 0x7fffa920c1ec</span><br><span class="line">getting page number of virtual address 140736030884332 of process 3437</span><br><span class="line">opening pagemap /proc/3437/pagemap</span><br><span class="line">moving to 274875060320</span><br><span class="line">physical frame address is 0x67337</span><br><span class="line">physical address is 0x673371ec</span><br></pre></td></tr></table></figure>
<p>GREAT! At last we conquered. We saw the evidence of our beloved <em>COW</em>. Now I can sleep peacefully.</p>
<h3 id="For-pure-Engineer"><a href="#For-pure-Engineer" class="headerlink" title="For pure Engineer"></a>For pure Engineer</h3><p>Still I feel the urge to make a stack write in child process and see the physical address change. For those curious people out there who want to see the things break, lets run it one more time. Change the <code>run()</code> function as follows and execute <code>specimen.c</code>.<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">run</span><span class="params">(<span class="keyword">void</span> *arg)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	*(<span class="keyword">int</span>*)arg = <span class="number">10</span>; <span class="comment">//stack write</span></span><br><span class="line">	<span class="keyword">while</span>(*(<span class="keyword">int</span>*)arg);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ ./specimen </span><br><span class="line">my pid is 3549 and address to check is 0x7ffdd8e1e9ac</span><br></pre></td></tr></table></figure>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">$ sudo ./get_paddr 3549 0x7ffdd8e1e9ac</span><br><span class="line">getting page number of virtual address 140728242137516 of process 3549</span><br><span class="line">opening pagemap /proc/3549/pagemap</span><br><span class="line">moving to 274859847920</span><br><span class="line">physical frame address is 0x634e6</span><br><span class="line">physical address is 0x634e69ac</span><br><span class="line">$</span><br><span class="line">$ sudo ./get_paddr 3550 0x7ffdd8e1e9ac</span><br><span class="line">getting page number of virtual address 140728242137516 of process 3550</span><br><span class="line">opening pagemap /proc/3550/pagemap</span><br><span class="line">moving to 274859847920</span><br><span class="line">physical frame address is 0x55976</span><br><span class="line">physical address is 0x559769ac</span><br><span class="line">$</span><br></pre></td></tr></table></figure>
<p>Good Nightzzz…</p>

  </div>
  
<nav class="footer-nav">
  
    <div class="footer-nav__prev">
      <div class="footer-nav__label">
        Newer
      </div>
      <a href="/Raspberry-Pi-dishes-from-Yocto-cuisine/">
        Raspberry Pi dishes from Yocto cuisine
      </a>
    </div>
  
  
    <div class="footer-nav__next">
      <div class="footer-nav__label">
        Older
      </div>
      <a href="/Virtual-memory-to-Physical-memory/">
        Virtual memory to Physical memory
      </a>
    </div>
  
</nav>


</article>


      </div>
      <div class="sidebar column is-4">
        <aside>
  
    <aside class="search widget">
  <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form" target="_blank">
    <div class="control has-icons-right">
      <input type="search" name="q" class="input" placeholder="Search">
      <span class="icon is-small is-right">
        <i class="fa fa-search"></i>
      </span>
    </div>
    <input type="hidden" name="sitesearch" value="https://eastrivervillage.com">
  </form>
</aside>

  
    <div class="widget-wrap">
  <div class="widget-title">author</div>
  <aside class="profile media widget">
    <!--figure class="profile-avatar media-left">
      <img src="/images/profile_author.jpg" class="avatar" alt="Balakumaran Kannan">
    </figure-->
    <div class="media-content">
      <p>
        <strong>
          <span>Balakumaran Kannan</span>
        </strong>
        <br>
        <span>System software engineer specilied in Linux. Experience spans from ARM32 board bring-up to multi datacenter cloud management. Open source contributer. From Bangalore, India.</span>
        <br/>
        <br/>
        <a href="/about" target="_blank">
          <span style="color: orangered;text-decoration-line: underline;">Contact me</span>
        </a>
      </p>
    </div>
  </aside>
</div>

  
    
  <div class="widget-wrap">
    <div class="widget-title">recents</div>
    <div class="widget">
      <ul class="recent-post">
        
          <li class="recent-post-item media">
            <figure class="media-left">
              
  <a href="/perf-kvm-to-profile-vm-exit/">
    <img src="/images/music-equalizer-1.jpg" class="thumbnail is-6x6" alt="perf kvm to profile vm_exit">
  </a>


            </figure>
            <div class="media-content">
              <p class="">
                <a href="/perf-kvm-to-profile-vm-exit/" class="">
                  perf kvm to profile vm_exit
                </a>
              </p>
              <p class="">
                <!--small>
                  2020-09-28

                </small>
                <br/-->
                <small>
                  
  <div class="tags">
    
      <a class="tag is-white" style="color: darkmagenta; padding-left:0;" href="/tags/linux/">linux</a>
    
      <a class="tag is-white" style="color: darkmagenta; padding-left:0;" href="/tags/perf/">perf</a>
    
  </div>


                </small>
              </p>
            </div>
          </li>
        
          <li class="recent-post-item media">
            <figure class="media-left">
              
  <a href="/kexec-tools-with-the-hidden-purgatory/">
    <img src="/images/purgatory.jpg" class="thumbnail is-6x6" alt="kexec - A travel to the purgatory">
  </a>


            </figure>
            <div class="media-content">
              <p class="">
                <a href="/kexec-tools-with-the-hidden-purgatory/" class="">
                  kexec - A travel to the purgatory
                </a>
              </p>
              <p class="">
                <!--small>
                  2020-01-20

                </small>
                <br/-->
                <small>
                  
  <div class="tags">
    
      <a class="tag is-white" style="color: darkmagenta; padding-left:0;" href="/tags/kernel/">kernel</a>
    
      <a class="tag is-white" style="color: darkmagenta; padding-left:0;" href="/tags/linux/">linux</a>
    
      <a class="tag is-white" style="color: darkmagenta; padding-left:0;" href="/tags/ARMv8/">ARMv8</a>
    
      <a class="tag is-white" style="color: darkmagenta; padding-left:0;" href="/tags/crazy-debugging/">crazy debugging</a>
    
  </div>


                </small>
              </p>
            </div>
          </li>
        
          <li class="recent-post-item media">
            <figure class="media-left">
              
  <a href="/Variadic-functions-with-unknown-argument-count/">
    <img src="/images/Variadic-functions-with-unknown-argument-count.jpg" class="thumbnail is-6x6" alt="Variadic functions with unknown argument count">
  </a>


            </figure>
            <div class="media-content">
              <p class="">
                <a href="/Variadic-functions-with-unknown-argument-count/" class="">
                  Variadic functions with unknown argument count
                </a>
              </p>
              <p class="">
                <!--small>
                  2019-06-29

                </small>
                <br/-->
                <small>
                  
  <div class="tags">
    
      <a class="tag is-white" style="color: darkmagenta; padding-left:0;" href="/tags/programming/">programming</a>
    
      <a class="tag is-white" style="color: darkmagenta; padding-left:0;" href="/tags/C/">C</a>
    
  </div>


                </small>
              </p>
            </div>
          </li>
        
          <li class="recent-post-item media">
            <figure class="media-left">
              
  <a href="/Custom-build-kernel-for-Raspberry-Pi/">
    <img src="/images/custom_kernel_rpi3.jpg" class="thumbnail is-6x6" alt="Custom build kernel for Raspberry Pi">
  </a>


            </figure>
            <div class="media-content">
              <p class="">
                <a href="/Custom-build-kernel-for-Raspberry-Pi/" class="">
                  Custom build kernel for Raspberry Pi
                </a>
              </p>
              <p class="">
                <!--small>
                  2019-03-30

                </small>
                <br/-->
                <small>
                  
  <div class="tags">
    
      <a class="tag is-white" style="color: darkmagenta; padding-left:0;" href="/tags/kernel/">kernel</a>
    
      <a class="tag is-white" style="color: darkmagenta; padding-left:0;" href="/tags/linux/">linux</a>
    
      <a class="tag is-white" style="color: darkmagenta; padding-left:0;" href="/tags/raspberrypi/">raspberrypi</a>
    
  </div>


                </small>
              </p>
            </div>
          </li>
        
          <li class="recent-post-item media">
            <figure class="media-left">
              
  <a href="/64-bit-Mainline-kernel-on-Raspberry-Pi-3/">
    <img src="/images/64bit_kernel_rpi3.jpg" class="thumbnail is-6x6" alt="64-bit Mainline kernel on Raspberry Pi 3">
  </a>


            </figure>
            <div class="media-content">
              <p class="">
                <a href="/64-bit-Mainline-kernel-on-Raspberry-Pi-3/" class="">
                  64-bit Mainline kernel on Raspberry Pi 3
                </a>
              </p>
              <p class="">
                <!--small>
                  2018-10-06

                </small>
                <br/-->
                <small>
                  
  <div class="tags">
    
      <a class="tag is-white" style="color: darkmagenta; padding-left:0;" href="/tags/kernel/">kernel</a>
    
      <a class="tag is-white" style="color: darkmagenta; padding-left:0;" href="/tags/linux/">linux</a>
    
      <a class="tag is-white" style="color: darkmagenta; padding-left:0;" href="/tags/raspberrypi/">raspberrypi</a>
    
  </div>


                </small>
              </p>
            </div>
          </li>
        
      </ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">tag cloud</h3>
    <div class="widget">
      <a href="/tags/ARM/" style="font-size: 10px;">ARM</a> <a href="/tags/ARMv8/" style="font-size: 13.33px;">ARMv8</a> <a href="/tags/C/" style="font-size: 10px;">C</a> <a href="/tags/Linux/" style="font-size: 10px;">Linux</a> <a href="/tags/RaspberryPi/" style="font-size: 16.67px;">RaspberryPi</a> <a href="/tags/about/" style="font-size: 10px;">about</a> <a href="/tags/bitbucket/" style="font-size: 10px;">bitbucket</a> <a href="/tags/build/" style="font-size: 13.33px;">build</a> <a href="/tags/c/" style="font-size: 10px;">c</a> <a href="/tags/chatbot/" style="font-size: 10px;">chatbot</a> <a href="/tags/clone/" style="font-size: 10px;">clone</a> <a href="/tags/compiler/" style="font-size: 10px;">compiler</a> <a href="/tags/cow/" style="font-size: 10px;">cow</a> <a href="/tags/crazy-debugging/" style="font-size: 10px;">crazy debugging</a> <a href="/tags/debug/" style="font-size: 13.33px;">debug</a> <a href="/tags/devpost/" style="font-size: 10px;">devpost</a> <a href="/tags/digitalocean/" style="font-size: 13.33px;">digitalocean</a> <a href="/tags/facebook/" style="font-size: 10px;">facebook</a> <a href="/tags/fork/" style="font-size: 10px;">fork</a> <a href="/tags/gcc/" style="font-size: 10px;">gcc</a> <a href="/tags/gdb/" style="font-size: 13.33px;">gdb</a> <a href="/tags/getpid/" style="font-size: 10px;">getpid</a> <a href="/tags/git/" style="font-size: 10px;">git</a> <a href="/tags/github/" style="font-size: 10px;">github</a> <a href="/tags/kernel/" style="font-size: 20px;">kernel</a> <a href="/tags/kernel-module/" style="font-size: 10px;">kernel module</a> <a href="/tags/linux/" style="font-size: 20px;">linux</a> <a href="/tags/memory-management/" style="font-size: 13.33px;">memory management</a> <a href="/tags/memory-management/" style="font-size: 10px;">memory_management</a> <a href="/tags/nodejs/" style="font-size: 13.33px;">nodejs</a> <a href="/tags/perf/" style="font-size: 10px;">perf</a> <a href="/tags/proc/" style="font-size: 10px;">proc</a> <a href="/tags/programming/" style="font-size: 10px;">programming</a> <a href="/tags/raspberrypi/" style="font-size: 13.33px;">raspberrypi</a> <a href="/tags/setup/" style="font-size: 13.33px;">setup</a> <a href="/tags/stack/" style="font-size: 10px;">stack</a> <a href="/tags/swap/" style="font-size: 10px;">swap</a> <a href="/tags/system-call/" style="font-size: 10px;">system call</a> <a href="/tags/ubuntu/" style="font-size: 10px;">ubuntu</a> <a href="/tags/vim/" style="font-size: 10px;">vim</a> <a href="/tags/virtual-memory/" style="font-size: 10px;">virtual_memory</a> <a href="/tags/vnc/" style="font-size: 10px;">vnc</a> <a href="/tags/wit-ai/" style="font-size: 10px;">wit.ai</a> <a href="/tags/yocto/" style="font-size: 20px;">yocto</a>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">archives</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/09/">September 2020</a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/01/">January 2020</a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/06/">June 2019</a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/03/">March 2019</a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/10/">October 2018</a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/09/">September 2018</a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/06/">June 2018</a><span class="archive-list-count">2</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/05/">May 2018</a><span class="archive-list-count">2</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/04/">April 2018</a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/03/">March 2018</a><span class="archive-list-count">5</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/02/">February 2018</a><span class="archive-list-count">2</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/09/">September 2017</a><span class="archive-list-count">1</span></li></ul>
    </div>
  </div>


  
</aside>

      </div>
    </div>
  </div>
  <footer class="footer">
  <div class="container">
    <div class="content has-text-centered">
      <p>
        <a rel="license" href="http://creativecommons.org/licenses/by-sa/4.0/deed.ja">
          <img alt="creative commons logo" style="border-width:0" src="https://i.creativecommons.org/l/by-sa/4.0/88x31.png" />
        </a>
        <br />
        <span xmlns:cc="http://creativecommons.org/ns#" property="cc:attributionName">this post is available under a </span> <a rel="license" href="https://creativecommons.org/licenses/by/4.0/">Creative Commons Attribution ShareAlike license.</p>
    </div>
  </div>
</footer>


  <script>
    // HACK: custom style goes here
    tables = document.querySelectorAll('table');
    for (i = 0; i < tables.length; i++) {
      tables[i].classList.add("table", "is-bordered", "is-fullwidth");
    }
  </script>
</body>
</html>
